# **알고리즘**

<br>

## **정렬 (Comparisons)**

<br>

**Bubble Sort**

    1. 인접한 두 개의 데이터를 비교해가면서 정렬을 진행

    2. 가장 큰 값을 배열의 맨 끝에 이동시키면서 정렬하고자하는 원소의 개수만큼 두번 반복

    3. O(n^2)

<br>

**Selection Sort**

    1. 비교하고 있는 값의 인덱스를 저장

    2. 최종적으로 한번만 바꿔주지만, 여러번 비교하는 것은 Bubble Sort와 마찬가지

    3. O(n^2)

<br>

**Insertion Sort**

    1. i 번째를 정렬할 순서라고 가정

    2. 0 부터 i-1 까지의 원소들은 정렬되어 있다고 가정

    3. i 번째 원소와 i-1 번째 원소부터 0번째 원소까지 비교하면서 i 번째 원소가 비교하는 원소보다 클 경우 서로의 위치 변경

    4. 작을 경우 위치를 바꾸지 않고 다음 순서의 원소와 비교하면서 정렬

    5. 이 과정을 마지막 원소까지 반복

    6. O(n^2)

<br>

**Merge Sort**

    1. 정렬하고자 하는 배열의 크기를 작은 단위로 나누어 정렬하고자 하는 배열크기를 줄이는 원리 사용

    2. 복잡한 문제를 복잡하지 않은 문제로 분할하여 정복하는 방법

    3. 정복 후에는 결합의 과정을 거쳐야함

    4. 더이상 나누어지지 않을 때 까지 반 씩 분할하다가 더이상 나누어지지 않은 경우(원소가 하나인 배열일 때) 자기 자신을 반환.

    5. 원소가 하나라면 정렬할 필요가 없기 때문

    6. 반환한 값끼리 결합될 때, 비교가 이루어짐

    7. 비교 결과는 임시배열에 저장

    8. 임시 배열에 저장된 순서를 합쳐진 값으로 반환

    9. 실제 정렬은 나눈 것을 병합하는 과정에서 이루어짐

    10. 재귀적 정렬

    11. O(nlogn)

<br>

**Heap Sort**

    1. 데이터 저장 : O(logn)

    2. 데이터 삭제 : O(logn)

    3. Heap을 이용하여 Sorting하면 O(logn)

    4. 정렬하려는 대상이 n개라면 O(nlogn)

<br>

**Quick Sort**

    1. 가장 빠른 정렬이라고 Quick 이 붙음

    2. 하지만 최악의 경우 O(n^2) 가 나올 수 있음

    3. 분할 정복 기법을 사용하여 이루어짐

    4. 분할 과정에서 pivot이라는 개념 사용

    5. 입력된 배열에 대해 오름차순으로 정렬한다고 가정

    6. 이 pivot을 기준으로 좌측은 pivot으로 설정한 값보다 작은 값이 위치

    7. 우측은 큰 값이 위치 하도록 partition됨

    8. 이렇게 나눈 좌우측 배열을 다시 재귀적으로 Quick Sort 시키면 또 partition 과정 수행

    9. 주의할점은 partition 과정에서 pivot으로 설정된 값은 다음 재귀과정에 포함 X

    10. 왜냐하면 partition 과정에서 정렬된 자신의 위치를 찾았기 때문

<br>

    최악의 경우

        Quick Sort로 오름차순 정렬 가정

        최악의 경우는 partition 과정에서 pivot이 항상 배열내에서 가장 작은 값
        또는 가장 큰 값으로 설정 되었을 때

        매 partition마다 unbalanced partition 이뤄짐

        이렇게 파티션이 되면 비교 횟수는 원소 n개에 대해서
        n번, (n-1)번, (n-2)번.... 이 되므로 O(n^2)

    Balanced-partitioning

        partition 과정에서 반반씩 나뉘게 되는 경우

        partition 과정에서 pivot을 어떻게 정할 것인가가 중요

        정확히 반반의 partition이 아니더라도 어떻게하면 balanced partitioning을 할 수 있을까?

        특정 위치의 원소를 pivot으로 설정하지 않고 배열 내의 원소 중 임의의 원소를 pivot으로
        설정하면 입력에 관계없이 일정한 수준을 얻을 수 있음

        악의 적인 입력에 대해 성능 저하를 막을 수 있음

    Partitioning

        가장 마지막 원소를 pivot으로 설정 했다고 가정

        이 pivot의 값을 기준으로 좌측에는 작은 값, 우측에는 큰 값이 오도록 해야함

        일단 pivot은 움직이지 않도록 고정

        첫번째 원소부터 비교하는데 만약 그 값이 pivot 보다 작으면 그대로 둔다

        크다면 맨 마지막에서 그 앞의 원소와 자리를 바꾼다.

        즉, pivot 값의 index가 k라면 k-1 번째와 바꿔주는 것

        이 모든 원소에 대해 실행하고 마지막 과정에서 작은 값들이 채워지는 인덱스를 가리키고
        있는 값에 1을 더한 index 값과 pivot 값을 바꿔 줌

        즉, 최종적으로 결정될 pivot의 인덱스를 i라고 했을 때
        0부터 i-1 까지는 pivot 보다 작은 값이 될 것이고
        i+1 부터 k까지는 pivot 값보다 큰 값이 될 것이다.

<br>