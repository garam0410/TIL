# **데이터베이스**

<br>

## **Join**
<br>

    관계형 데이터베이스에서 중복 데이터를 비하기 위해 데이터를 테이블로 나눠서 저장
    이때 두개이상의 테이블을 결합하여 데이터를 검색하는 방법

**내부조인 VS 외부조인**

    내부 조인은 공통분모 즉, 교집합
    외부 조인은 한테이블에만 데이터가 있는 경우, 데이터가 있는 테이블의 내용 전부 출력

<br>

## **정규화**

<br>

    이상 문제(삽입, 삭제, 갱신) 을 해결하기 위해 종속 관계를 분석하여 여러개의 릴레이션으로 분해하는 과정

    분해시 속도는 느려질 수 있지만, 이상 문제 해결

<br>

## **인덱스(Index)**

<br>

    1. 추가적인 쓰기 작업과 저장 공간을 활용하여 데이터베이스 테이블의 검색 속도를 향상시키기 위한 자료구조
    
    2. 만약, 책에서 원하는 내용을 찾는다고 하면, 책의 모든 페이지를 찾아보는 것은 오랜 시간이 걸림

    3. 그렇기 대문에 책의 저자들은 책의 맨 앞 또는 맨 뒤에 색인을 추가
        -> 인덱스는 책의 색인
    
    4. 데이터베이스에서도 테이블의 모든 데이터를 검색하면 시간이 오래걸리기 때문에 데이터와 데이터의 위치를 포함한 자료구조를 생성하여 빠르게 조회할 수 있도록 함

    5. 만약, 인덱스를 적용하지 않은 컬럼을 조회하면, 전체를 탐색하는 Full Scan 수행

    6. 이때는 전체를 비교하기 때문에 처리속도가 떨어짐

**인덱스 자료구조**

<br>

    해시 테이블

        - 컬럼의 값으로 생성된 해시를 기반으로 인덱스 구함

        - 시간복잡도가 O(1) 이라 검색이 매우 빠름

        - 부등호(<,>) 와 같은 연속적인 데이터를 위한 순차 검색 불가
    
    B-Tree

        - 리프노드, 브랜치노드 모두 데이터 저장 가능
        - 트리 높이가 높고, 모든 노드 탐색

    B+Tree

        - 자식 노드가 2개 잇아인 B-Tree를 개선 시킨 자료구조

        - BTree의 리프노드들을 LinkedList로 연결하여 순차 검색을 용이하게 함

        - 해시 테이블보다 나쁜 O(log2n * log2n)의 시간 복잡도를 갖지만 해시 테이블 보다 흔하게 사용

<br>

**클러스터링 VS 리플리케이션**

<br>

**리플리케이션**

    1. 여러개의 DB를 권한에 따라 수직적인 구조 (Master-Slave) 로 구축하는 방식
    
    2. 비동기 방식으로 노드들 간의 데이터를 동기화

    장점

        - 비동기 방식으로 데이터가 동기화되어 지연시간이 거의 없음

    단점

        - 노드들 간의 데이터가 동기화되지 않아 일관성 있는 데이터를 얻지 못할 수 있음

<br>

**클러스터링**

    1. 여러 개의 DB를 수평적인 구조로 구축하여 Fail Over한 시스템을 구축하는 방식

    2. 동기 방식으로 노드들 간의 데이터를 동기화

    장점

        - 1개의 노드가 죽어도 다른 노드가 살아 있어 시스템을 장애 없이 운영 가능

    단점

        - 여러 노드들 간의 데이터를 동기화하는 시간이 필요하므로 리플리케이션에 비해
        쓰기 성능이 떨어짐 

<br>

## **트랜잭션**

<br>

    DB 상태를 변환시키는 하나의 논리적인 기능을 수행하기 위한 작업 단위
    한꺼번에 수행되어야할 연산

## **ACID**

    - Atomicity (원자성) 
        
        트랜잭션 연산이 모두 반영 혹은 전혀 반영되지 않아야함
        하나라도 오류 시 전부취서
    
    - Consistency (일관성)

        트랜잭션이 실행 후 언제나 일관성
        시스템 고정 요소 트랜잭션 전후가 같아야함
    
    - Isolation (독립성)

        병행 실행시 다른 트랜잭션 끼어들 수 없음
        수행중 트랜잭션 완료시까지 결과 참조 X
    
    - Durablility (영속성)

        성공적인 트랜잭션 결과는 시스템 고장시에도 영구적 반영
    
<br>

## **트랜잭션 격리 수준**

    동시에 여러개의 트랜잭션이 처리될 때, 특정 트랜잭션이 다른 트랜잭션에서 변경하거나 조회한 데이터를 볼 수 있도록 허용 여부를 결정하는 것

<br>

## **공유 락 VS 배타 락**

    트랜잭션이 읽기를 할 때 사용하는 공유 락
    읽고 쓰기를 할 때 상요하는 베타 락

<br>

## **DeadLock**

    두 개 이상의 트랜잭션이 각각 자신의 데이터에 대하여 락을 획득하고 상대방 데이터에 대하여 락을 요청하면 무한 대기 상태에 빠지는 현상

<br>

## **SQL**

<br>

    RDBMS에서 데이터 저장, 수정, 삭제 및 검색 가능

    정해진 구조에 맞는 레코드만 추가가 가능한 것이 관계형 데이터베이스의 특징

    핵심 특징

        - 데이터는 정해진 데이터 스키마에 따라 테이블에 저장

        - 데이터는 관계를 통해 여러 테이블에 분산

<br>

## **NoSQL**

<br>

    관계형 데이터베이스와 반대
    
    스키마도 없고 관계도 없음

    레코드 = 문서(Documents)

    SQL과 달리 다른 구조의 데이터를 추가 가능

    문서는 JSON과 비슷한 형태로 가지고 있음

    관계형 데이터베이스와는 달리, 관련 데이터를 동일한 컬렉션에 넣음

    여러 테이블에 조인할 필요 없이 이미 필요한 모든 것을 갖춘 문서를 작성하는 것

    컬렉션을 통해 데이터를 복제하여 각 컬렉션 일부분에 속하는 데이터를 정확하게 산출함으로 써 조인이 가능

    하지만 이러면 데이터가 중복되어 서로 영향을 줄 위험이 큼

    따라서 조인을 잘 사용하지 않고 자주 변경되지 않는 데이터일 때 NoSQL을 쓰면 좋음

<br>

## **데이터베이스 확장**

<br>

    수직적 확장 (SQL)

        데이터 베이스 서버의 성능을 향상 시키는 것

    수평적 확장 (NoSQL)

        더 많은 서버가 추가되고 데이터베이스가 전체적으로 분산됨을 의미

<br>

## **둘중에 선택**

<br>

**SQL**

    관계를 맺고 있는 데이터가 자주 변경되는 어플리케이션의 경우

    변경될 여지가 없고, 명확한 스키마가 사용자와 데이터에게 중요한 경우


    SQL 장점

        - 명확하게 정의된 스키마

        - 데이터 무결성 보장

        - 관계는 각 데이터를 중복없이 한번만 저장

    SQL 단점

        - 덜 유연함, 스키마를 사전에 계획하고 알려야 함 (수정이 힘듦)

        - 관계를 맺고 있어서 조인문이 많은 복잡한 쿼리가 만들어질 수 있음

        - 수직적 확장만 가능
    
<br>

**NoSQL**

    정확한 데이터 구조를 알 수 없거나 변경/확장 될 수 있는 경우

    읽기를 자주 하지만, 데이터 변경은 자주 없는 경우
    
    데이터베이스를 수평으로 확장해야 하는 경우
    -> 막대한 양의 데이터를 다뤄야 하는 경우


    NoSQL 장점

        - 스키마가 없어서 유연함

        - 언제든지 저장된 데이터를 조정하고 새로운 필드 추가 가능

        - 데이터는 어플리케이션이 필요로 하는 형식으로 저장

        - 데이터 읽어오는 속도 빨라짐

        - 수직 및 수평 확장이 가능해서 어플리케이션이 발생시키는 모든 읽기/쓰기 요청 처리 가능
    
    NoSQL 단점

        - 유연성으로 인해 데이터 구조 결정을 미루게 될 수 있음

        - 데이터 중복을 계속 업데이트 해야 함

        - 데이터가 여러 컬렉션에 중복되어 있기 때문에 수정시, 모든 컬렉션에서 수행

<br>
