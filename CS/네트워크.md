# **네트워크**

<br>

## **GET & POST**

<br>

**GET**

    1. 요청하는 데이터가 HTTP Request Message의 Header 부분에 URL이 담겨서 전송

    2. url상에 ? 뒤에 데이터가 붙어 request

    3. url이라는 공간에 담겨가기 떄문에 전송할 수 있는 크기가 제한적

    4. 보안이 필요한 데이터에 대해서는 데이터가 그대로 노출되기 때문에 적절하지 않음

    5. 브라우저에서 캐싱할 수 있음

    6. 그렇기 때문에 기존에 캐싱 되었던 데이터가 응답될 가능성 존재

<br>

**POST**

    1. Body 부분에 데이터가 담겨서 전송

    2. 바이너리 데이터를 요청하는 경우 POST 방식으로 보내야하는 것처럼 데이터 크기가 GET 방식보다 크고 보안면에서 좋음
    (하지만 보안 적인 측면에서 암호화를 하지 않는 이상 비슷함)

<br>

## **TCP & UDP**

<br>

**UDP**

    1. 비 연결형 프로토콜

    2. IP 데이터그램을 캡슐화하여 보내는 방법과 연결 설정을 하지않고 보내는 방법 제공

    3. 흐름제어, 오류제어, 손상된 세그먼트 수신에 대한 재전송 X

    4. 이 모든 것은 상요자 프로세스의 몫

    5. 포트들을 사용하여 IP 프로토콜에 인터페이스를 제공하는 것

    6. 종종 클라이언트가 서버에 짧은 요청을 보내고 짧은 응답을 기대함

    7. 만약 요청 또는 응답이 손실되면, 클라이언트는 timeout 되고, 다시 시도하면 됨

    8. UDP는 이 과정에서 코드가 간단하고 TCP 처럼 초기 설정에서 요구되는 프로토콜보다
    더 적은 메시지가 요구

    9. DNS

        - 어떤 호스트 네임의 IP주소를 찾을 필요가 있는 프로그램은 DNS 서버로 호스트
        네임을 포함한 UDP 패킷을 보냄

        - 이 서버는 호스트의 IP 주소를 포함한 UDP 패킷으로 응답

        - 사전 설정이 필요하지 않으며 그 후에 해제가 필요하지 않음

<br>

**TCP**

    1. UDP로 만족할수 없는 신뢰성과 순차적인 전달을 만족시킴

    2. 신뢰성이 없는 인터넷을 통해 종단간에 신뢰성 있는 바이트 스트림을 전송하도록 설계

    3. 송신자와 수신자가 모두 소켓이라고 부르는 종단점을 생성함으로서 이루어짐

    4. 연결 설정은 3-way handshake를 통해 이루어짐

    5. 멀티캐스팅, 브로드캐스팅 지원 X

    6. 모든 연결은 전이중(full-duplex), 점대점(point to poing).

        - 전이중
            
            전송이 양방향으로 동시에 이루어질 수 있음

        - 점대점

            각 연결이 정확히 2개의 종단점을 가지고 있음

<br>

## **HTTP**

<br>

**문제점**

    1. 평문 통신이기 때문에 도청이 가능

    2. 통신 상대를 확인하지 않기 때문에 위장 가능

    3. 완전성을 증명할 수 없기 때문에 변조 가능

<br>

**TCP/IP는 도청 가능한 네트워크**

    1. TCP/IP 구조의 통신은 모두 통신경로 상에서 엿볼 수 있음

    2. 패킷을 수집하는 것 만으로도 도청 가능

    3. 평문으로 통신을 할 경우 메시지의 의미를 파악할 수 있기 때문에 암호화하여 통신해야 함

    보완 방법

        - 통신 자체를 SSL 또는 TLS 라는 다른 프로토콜을 조합함으로써 암호화
        
        - SSL 을 조합한 HTTP를 HTTPS 또는 HTTP over SSL 이라고 부름

        - HTTP 메시지에 포함되는 콘텐츠만 암호화 하는 것
        
        - 암호화해서 전송하면 받는 측에서는 암호를 해도갛여 출력하는 처리 필요

<br>

**완전성을 증명할 수 없기 대문에 변조가 가능**

    1. 완전성 = 정보의 정확성

    2. 서버 또는 클라이언트에서 수신한 내용이 송신측에서 보낸 내용과 일치한다라는 것을 보장할 수 없는 것

    3. 요청 또는 응답 발생후에 상대가 수신하는 사이 누군가에 의해 변조되더라도 사실을 알 수 없음

    4. 이처럼 공격자가 도중에 요청이나 응답을 빼앗아 변조하는 공격을 중간자 공격이라고 함

    보완 방법

        - MD5, SHA-1 등의 해시 값을 확인하는 방법과 파일의 디지털 서명을 확인하는 방법 존재

        - 하지만 위 방법은 확실히 확인할 수 있는 것은 아님

        - 확실히 방지하기 위해서는 HTTPS 를 사용해야함

        - HTTPS 는 인증, 암호화, 다이제스트 기능 제공

<br>

## **HTTPS**

<br>

    1. SSL의 껍질을 덮어쓴 HTTP

    2. 새로운 어플리케이션 계층의 프로토콜은 아님

    3. HTTP 통신하는 소켓 부분을 SSL 또는 TLS 라는 프로토콜로 대체하는 것

    4. HTTP가 TCP와 직접 통신 했다면, HTTPS에서 HTTP는 SSL과 통신하고 SSL이 TCP와 통신

    5. SSL을 사용한 HTTPS는 암호화와 증명서, 안전성 보호를 이용할 수 있음

    6. HTTPS의 SSL 에서는 공통키 암호화 방식과 공개키 암호화 방식을 혼합한 하이브리드 암호 시스템 사용

    7. 이는 공통키를 공개키 암호화 방식으로 교환한 다음에 다음부터의 통신은 공통키 암호르 사용하는 방식

<br>

**모든 웹페이지에서 HTTPS를 사용?**

    1. 평문 통신에 비해 암호화 통신인 CPU, 메모리 등의 리소스를 더 많이 요구

    2. 통신할 때마다 추가적인 리소스를 소비하기 때문에 서버한 대당 처리할 수 있는 요청의 수가 줄어듦

    3. 최근에는 하드웨어 발다로 인해 HTTPS를 사용하더라도 속도 저하가 거의 일어나지 않음

    4. HTTP 2.0과 함께 사용한다면 오히려 HTTP 보다 빠름

    5. 과거에 민감한 정보를 다룰때만 HTTPS를 사용했지만, 현재 모든 웹페이지에서 HTTPS를 적용하는 방향으로
    바뀌고 있음

<br>